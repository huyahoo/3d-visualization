<!-- Licensed under a BSD license. See license.html for license -->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Three.js - Basic Cube</title>
  <style>
    html,
    body {
      width: 50%;
      height: 50%;
      margin: 0;
    }

    #c {
      width: 50%;
      height: 50%;
      display: block;
    }
  </style>
</head>

<body>
  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    var scene = new THREE.Scene();
    const gui = new GUI();

    var aspect = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(
      75,
      aspect,
      0.1,
      1000
    );
    camera.position.set(0, 0, 20);

    var renderer = new THREE.WebGLRenderer({
      antialias: true,
    });

    renderer.setSize(
      window.innerWidth,
      window.innerHeight
    );
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(
      camera,
      renderer.domElement
    );

    // GUI Walls Controller
    class WallController {
      constructor(gui, leftBoardMesh, rightBoardMesh, frontBoardMesh, topBoardMesh, bottomBoardMesh) {
        this.gui = gui;
        this.leftBoardMesh = leftBoardMesh;
        this.rightBoardMesh = rightBoardMesh;
        this.frontBoardMesh = frontBoardMesh;
        this.topBoardMesh = topBoardMesh;
        this.bottomBoardMesh = bottomBoardMesh;
        this.wallsObj = {
          leftSide: 0xff0000,
          rightSide: 0x00ff00,
          FrontSide: 0x6a6b6c,
          topSide: 0x6a6b6c,
          bottomSide: 0x6a6b6c,
          viewSide: 'Front Side',
        };
        this.createGUI();
      }

      createGUI() {
        const wallsFolder = this.gui.addFolder('Walls');

        wallsFolder.addColor(this.wallsObj, 'leftSide').onChange(() => this.updateColor(this.leftBoardMesh, 'leftSide'));
        wallsFolder.addColor(this.wallsObj, 'rightSide').onChange(() => this.updateColor(this.rightBoardMesh, 'rightSide'));
        wallsFolder.addColor(this.wallsObj, 'FrontSide').onChange(() => this.updateColor(this.frontBoardMesh, 'FrontSide'));
        wallsFolder.addColor(this.wallsObj, 'topSide').onChange(() => this.updateColor(this.topBoardMesh, 'topSide'));
        wallsFolder.addColor(this.wallsObj, 'bottomSide').onChange(() => this.updateColor(this.bottomBoardMesh, 'bottomSide'));

        wallsFolder.add(this.wallsObj, 'viewSide', ['Front Side', 'Back Side', 'Double Side']).onChange(() => this.updateSide());
      }

      updateColor(mesh, propertyName) {
        mesh.material.color.set(this.wallsObj[propertyName]);
      }

      updateSide() {
        const side = this.getMaterialSide();
        [this.leftBoardMesh, this.rightBoardMesh, this.frontBoardMesh, this.topBoardMesh, this.bottomBoardMesh].forEach(mesh => {
          mesh.material.side = side;
        });
      }

      getMaterialSide() {
        switch (this.wallsObj.viewSide) {
          case 'Front Side':
            return THREE.FrontSide;
          case 'Back Side':
            return THREE.BackSide;
          case 'Double Side':
            return THREE.DoubleSide;
          default:
            return THREE.FrontSide;
        }
      }
    }

    // GUI Lights Controller
    class LightControls {
      constructor(scene, gui, lights) {
        this.scene = scene;
        this.gui = gui;
        this.lights = lights;
        this.enableControls = {};
        this.helperControls = {};
        this.createGUI();
      }

      sceneContains(object) {
        return scene.children.includes(object);
      }

      createGUI() {
        const folder = this.gui.addFolder('Lights');

        this.lights.forEach(light => {
          if (light instanceof THREE.DirectionalLight) {
            this.addDirectionalLightControls(light, folder);
          } else if (light instanceof THREE.PointLight) {
            this.addPointLightControls(light, folder);
          } else if (light instanceof THREE.SpotLight) {
            this.addSpotLightControls(light, folder);
          } else if (light instanceof THREE.HemisphereLight) {
            this.addHemisphereLightControls(light, folder);
          }
          scene.add(light);
        });
      }

      addDirectionalLightControls(light, folder) {
        const lightFolder = folder.addFolder('Directional Light');
        const helper = new THREE.DirectionalLightHelper(light);
        this.enableControls.directionalLight = true;
        this.helperControls.directionalLight = false;

        const toggleHelper = (value, isShowHelper) => {
          if (value && isShowHelper) {
            scene.add(helper);
          } else {
            scene.remove(helper);
          }
        };

        lightFolder.add(this.enableControls, 'directionalLight').name('Enable').onChange(value => {
          light.visible = value;
          toggleHelper(value, this.helperControls.directionalLight)
        });
        lightFolder.add(this.helperControls, 'directionalLight').name('Helper').onChange(value => {
          toggleHelper(value, value);
          this.helperControls.directionalLight = value;
        });
        lightFolder.addColor(light, 'color').onChange(() => light.color = new THREE.Color(light.color));
        lightFolder.add(light, 'intensity', 0, 2, 0.01);
        lightFolder.add(light.position, 'x', -10, 10);
        lightFolder.add(light.position, 'y', -10, 10);
        lightFolder.add(light.position, 'z', -10, 10);
      }

      addPointLightControls(light, folder) {
        const lightFolder = folder.addFolder('Point Light');
        this.enableControls.pointLight = true;
        this.helperControls.pointLight = false;

        const toggleHelper = (value, isShowHelper) => {
          if (value && isShowHelper) {
            scene.add(lightHelper);
          } else {
            scene.remove(lightHelper);
          }
        };

        lightFolder.add(this.enableControls, 'pointLight').name('Enable').onChange(value => {
          light.visible = value;
          toggleHelper(value, this.helperControls.pointLight)
        });
        lightFolder.add(this.helperControls, 'pointLight').name('Helper').onChange(value => {
          toggleHelper(value, value);
          this.helperControls.pointLight = value;
        });

        lightFolder.addColor(light, 'color').onChange(() => light.color = new THREE.Color(light.color));
        lightFolder.add(light, 'intensity', 0, 150, 1);
        lightFolder.add(light.position, 'x', -6, 6);
        lightFolder.add(light.position, 'y', -5, 5);
        lightFolder.add(light.position, 'z', 0, 8);
        lightFolder.add(light, 'distance', 0, 24, 0.1)
        lightFolder.add(light, 'decay', 0, 4, 0.1);
      }

      addSpotLightControls(light, folder) {
        const lightFolder = folder.addFolder('Spot Light');
        const helper = new THREE.SpotLightHelper(light);
        this.enableControls.spotLight = true;
        this.helperControls.spotLight = false;

        const toggleHelper = (value, isShowHelper) => {
          if (value && isShowHelper) {
            scene.add(helper);
          } else {
            scene.remove(helper);
          }
        };

        lightFolder.add(this.enableControls, 'spotLight').name('Enable').onChange(value => {
          light.visible = value;
          if (value && !this.sceneContains(light)) {
            scene.add(light);
          } else if (!value && this.sceneContains(light)) {
            scene.remove(light);
          }
        });

        lightFolder.add(this.helperControls, 'spotLight').name('Helper').onChange(value => {
          toggleHelper(value, value);
          this.helperControls.pointLight = value;
        });

        lightFolder.addColor(light, 'color').onChange(() => light.color = new THREE.Color(light.color));
        lightFolder.add(light, 'intensity', 0, 150, 1);
        lightFolder.add(light.position, 'x', -10, 10);
        lightFolder.add(light.position, 'y', -10, 10);
        lightFolder.add(light.position, 'z', -10, 10);
        lightFolder.add(light, 'distance', 0, 24, 0.1)
        lightFolder.add(light, 'decay', 0, 4, 0.1);
      }

      addHemisphereLightControls(light, folder) {
        const lightFolder = folder.addFolder('Hemisphere Light');
        this.enableControls.hemisphereLight = true;
        lightFolder.add(this.enableControls, 'hemisphereLight').name('Enable').onChange(value => {
          light.visible = value;
          if (value && !this.sceneContains(light)) {
            scene.add(light);
          } else if (!value && this.sceneContains(light)) {
            scene.remove(light);
          }
        });
        lightFolder.addColor(light, 'skyColor').onChange(() => light.color = new THREE.Color(light.color));
        lightFolder.addColor(light, 'groundColor').onChange(() => light.groundColor = new THREE.Color(light.groundColor));
        lightFolder.add(light, 'intensity', 0, 150, 1);
        lightFolder.add(light.position, 'x', -10, 10);
        lightFolder.add(light.position, 'y', -10, 10);
        lightFolder.add(light.position, 'z', -10, 10);
      }
    }
    // Ambient Light
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.05);
    scene.add(ambientLight);

    // Directional Light
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 4, 4);
    directionalLight.target.position.set(0, 0, 4);


    // Point Light
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(0, 0, 4);
    pointLight.intensity = 20;
    pointLight.distance = 16;
    pointLight.decay = 2;

    const lightHelper = new THREE.PointLightHelper(pointLight, 1);
    scene.add(lightHelper);

    // Spot Light
    const spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(0, 5, 4);
    spotLight.target.position.set(0, 0, 4);
    spotLight.angle = Math.PI / 4;
    spotLight.penumbra = 0.05;
    spotLight.decay = 2;
    spotLight.distance = 200;

    // Hemisphere Light
    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
    hemisphereLight.skyColor = new THREE.Color(0xffffbb);
    hemisphereLight.groundColor = new THREE.Color(0x080820);

    const lights = [directionalLight, pointLight, spotLight, hemisphereLight];
    const lightControls = new LightControls(scene, gui, lights);

    // AXES helper
    const axesHelper = new THREE.AxesHelper(100);
    scene.add(axesHelper);

    // Walls Front
    const frontBoardGeometry = new THREE.PlaneGeometry(12, 10);
    const frontBoardMesh = new THREE.Mesh(frontBoardGeometry, new THREE.MeshPhysicalMaterial({ color: 0x6a6b6c, side: THREE.FrontSide }));
    frontBoardMesh.position.set(0, 0, 0);

    // Walls Left
    const leftBoardGeometry = new THREE.PlaneGeometry(8, 10);
    const leftBoardMesh = new THREE.Mesh(leftBoardGeometry, new THREE.MeshPhysicalMaterial({ color: 0xff0000, side: THREE.FrontSide }));
    leftBoardMesh.position.set(-6, 0, 4);
    leftBoardMesh.rotation.y = 90 * Math.PI / 180;

    // Walls Right
    const rightBoardGeometry = new THREE.PlaneGeometry(8, 10);
    const rightBoardMesh = new THREE.Mesh(rightBoardGeometry, new THREE.MeshPhysicalMaterial({ color: 0x00ff00, side: THREE.FrontSide }));
    rightBoardMesh.position.set(6, 0, 4);
    rightBoardMesh.rotation.y = -90 * Math.PI / 180;

    // Walls Top
    const topBoardGeometry = new THREE.PlaneGeometry(12, 8);
    const topBoardMesh = new THREE.Mesh(topBoardGeometry, new THREE.MeshPhysicalMaterial({ color: 0x6a6b6c, side: THREE.FrontSide }));
    topBoardMesh.position.set(0, 5, 4);
    topBoardMesh.rotation.x = 90 * Math.PI / 180;

    // Walls Bottom
    const bottomBoardGeometry = new THREE.PlaneGeometry(12, 8);
    const bottomBoardMesh = new THREE.Mesh(bottomBoardGeometry, new THREE.MeshPhysicalMaterial({
      color: 0x6a6b6c,
      side: THREE.FrontSide
    }));
    bottomBoardMesh.position.set(0, -5, 4);
    bottomBoardMesh.rotation.x = -90 * Math.PI / 180;

    // Table
    const tableGeometry = new THREE.BoxGeometry(8, 2, 6);
    const tableMesh = new THREE.Mesh(tableGeometry, new THREE.MeshPhysicalMaterial({ color: 0x7f8389 }));
    tableMesh.position.set(0, -4, 4);

    // Cone
    const coneGeometry = new THREE.ConeGeometry(1.2, 4, 50, 1.8, false, Math.PI * 2.00, Math.PI * 2.00);
    const coneMesh = new THREE.Mesh(
      coneGeometry,
      new THREE.MeshLambertMaterial({
        color: 0x3ff7c3,
      }));
    coneMesh.position.set(-2, -1, 3);

    // Cylinder
    const CylinderGeometry = new THREE.CylinderGeometry(1.4, 1.4, 2.2, 50);
    const cylinderMesh = new THREE.Mesh(CylinderGeometry, new THREE.MeshPhongMaterial({ color: 0xf02e21 }));
    cylinderMesh.position.set(2, -1.9, 3);

    // Sphere
    const sphereGeometry = new THREE.SphereGeometry(0.9, 30, 30);
    const sphereMesh = new THREE.Mesh(sphereGeometry, new THREE.MeshPhysicalMaterial({ color: 0x6699ff }));
    sphereMesh.position.set(0, -2.1, 5);

    scene.add(frontBoardMesh, leftBoardMesh, rightBoardMesh, topBoardMesh, bottomBoardMesh, tableMesh);
    scene.add(coneMesh, cylinderMesh, sphereMesh);

    const wallController = new WallController(gui, leftBoardMesh, rightBoardMesh, frontBoardMesh, topBoardMesh, bottomBoardMesh);

    function createMesh(geometry, color, x, y, z, sideView, rotationX, rotationY, rotationZ) {
      const material = new THREE.MeshPhysicalMaterial({
        color: color,
      });

      if (sideView) {
        material.side = sideView;
      }
      const mesh = new THREE.Mesh(geometry, material);
      mesh.position.set(x, y, z);

      if (rotationX) {
        mesh.rotation.x = rotationX * Math.PI / 180;
      }
      if (rotationY) {
        mesh.rotation.y = rotationY * Math.PI / 180;
      }
      if (rotationZ) {
        mesh.rotation.z = rotationZ * Math.PI / 180;
      }

      return mesh;
    }

    function resizeRendererToDisplaySize(renderer) {
      const canvas = renderer.domElement;
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      const needResize =
        canvas.width !== width ||
        canvas.height !== height;
      if (needResize) {
        renderer.setSize(width, height, false);
      }
      return needResize;
    }

    function render() {
      if (resizeRendererToDisplaySize(renderer)) {
        const canvas = renderer.domElement;
        camera.aspect =
          canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      controls.update();
      renderer.render(scene, camera);

      requestAnimationFrame(render);
    }

    requestAnimationFrame(render);

    // render();
  </script>
</body>

</html>