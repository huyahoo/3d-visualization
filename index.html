<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <title>Color Points Cloud Visualization</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #aaaaaa;
      background-attachment: fixed !important;
      font-family: Monospace;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <script type="x-shader/x-vertex" id="RGBVertexShader">
		uniform sampler2D tex;
		varying vec3 color;

		void main() {
			color = texture2D ( tex, position.xy ).rgb;
			gl_PointSize = 1.0;
			gl_Position = projectionMatrix * modelViewMatrix * vec4(color-vec3(.5,.5,.5), 1.0);
		}
	</script>

  <script type="x-shader/x-fragment" id="RGBFragmentShader">
		varying vec3 color;
    out vec4 out_FragColor;

		void main() {
			out_FragColor.rgb = color;
			out_FragColor.a = 1.0;
		}
	</script>

  <script type="x-shader/x-vertex" id="ShadowVertexShader">
    uniform sampler2D tex;
    varying vec3 color;

    void main() {
      color = texture2D(tex, position.xy).rgb;
      gl_PointSize = 1.0;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(color.x, 0.0, color.z, 1.0);
    }
  </script>

  <script type="x-shader/x-fragment" id="ShadowFragmentShader">
    varying vec3 color;
    out vec4 out_FragColor;

    void main() {
      out_FragColor.rgb = vec3(0.0, 0.0, 0.0); // Color the fragment uniformly
      out_FragColor.a = 1.0; //opacity
    }
  </script>

  <script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import WEBGL from "three/addons/capabilities/WebGL.js";
    import { GUI } from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    // VR & XR Associated
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
    import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

    let hand1, hand2;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    const tmpVector1 = new THREE.Vector3();
    const tmpVector2 = new THREE.Vector3();

    var camera, controls, scene, renderer, container;
    var context, canvas;
    var plan;
    var colorSpacePoints, shadowSpacePoints, densityColorPoints;

    let grabbing = false;
    const scaling = {
      active: false,
      initialDistance: 0,
      object: null,
      initialScale: 1
    };
    const spheres = [];

    // Visualization Associated
    const gui = new GUI();

    // VIDEO AND THE ASSOCIATED TEXTURE
    var video, videoTexture;

    class SpaceMaterial {
      constructor(vertexShaderId, fragmentShaderId) {
        this.vertexShaderId = vertexShaderId;
        this.fragmentShaderId = fragmentShaderId;
        this.material = this.createMaterial();
      }

      createMaterial() {
        return new THREE.ShaderMaterial({
          vertexShader: document.getElementById(this.vertexShaderId).textContent,
          fragmentShader: document.getElementById(this.fragmentShaderId).textContent,
          glslVersion: THREE.GLSL3,
          uniforms: {
            tex: { value: videoTexture },
          },
        });
      }
    }

    function createBoxHelper(x, y, z) {
      // EdgesGeometry
      const size = 1;
      const edgesWidthSegments = 2;
      const edgesHeightSegments = 2;
      const edgesDepthSegments = 2;
      const boxGeometry = new THREE.BoxGeometry(
        size, size, size,
        edgesWidthSegments, edgesHeightSegments, edgesDepthSegments);
      const edgesGeometry = new THREE.EdgesGeometry(
        boxGeometry
      );
      const edges = new THREE.LineSegments(
        edgesGeometry,
        new THREE.LineBasicMaterial({ color: 0xffffff })
      );
      edges.position.set(x, y, z);

      // Grid Helper
      const gridHelper = new THREE.GridHelper(1, 10);
      gridHelper.position.set(x, y - 0.5, z);

      // Add to scene
      scene.add(gridHelper, edges);
    }

    function setPointsPosition(colorPoints, shadowPoints, x, y, z) {
      colorPoints.position.set(x, y, z);
      shadowPoints.position.set(x - .5, y - .5, z - .5);
      scene.add(colorPoints, shadowPoints);
      createBoxHelper(x, y, z);
    }

    function setVisible(visible, meshList, colorPoints, shadowPoints) {
      meshList.forEach((mesh) => {
        scene.remove(mesh);
      })
      if (visible) {
        scene.add(colorPoints, shadowPoints);
      }
    }

    function createGUI(meshList) {
      const colorSpaceObj = {
        colorSpace: 'RGB',
        density: false,
      }

      function selectSpacePoints(colorSpace, show) {
        const spacePoints = {
          'RGB': show ? densityColorPoints : colorSpacePoints,
          'CIExyY': show ? densityColorPoints : colorSpacePoints,
          'CIELAB': show ? densityColorPoints : colorSpacePoints,
        }

        return spacePoints[colorSpace];
      }

      var pausePlayObj = {
        pausePlay: function () {
          if (!video.paused) {
            video.pause();
          } else {
            video.play();
          }
        },
        add10sec: function () {
          video.currentTime = video.currentTime + 10;
          console.log(video.currentTime);
        },
      };

      gui.add(colorSpaceObj, 'colorSpace', ['RGB', 'CIExyY', 'CIELAB']).name('Color Space').onChange((value) => {
        setVisible(false, meshList);
        colorSpaceObj.colorSpace = value;
        switch (value) {
          case 'RGB':
            setVisible(true, meshList, selectSpacePoints(value, colorSpaceObj.density), shadowSpacePoints);
            break;
          case 'CIExyY':
            setVisible(true, meshList, selectSpacePoints(value, colorSpaceObj.density), shadowSpacePoints);
            break;
          case 'CIELAB':
            setVisible(true, meshList, selectSpacePoints(value, colorSpaceObj.density), shadowSpacePoints);
            break;
          default:
            break;
        }
      });

      gui.add(colorSpaceObj, 'density').name('Visualize Density').onChange((value) => {
        colorSpaceObj.density = value;
        setVisible(true, meshList, selectSpacePoints(colorSpaceObj.colorSpace, value), shadowSpacePoints);
      });

      gui.add(pausePlayObj, "pausePlay").name("Pause/play video");
      gui.add(pausePlayObj, "add10sec").name("Add 10 seconds");
    }

    // VR Associated Function
    const SphereRadius = 0.05;
    function onPinchStartLeft(event) {
      const controller = event.target;
      if (grabbing) {
        const indexTip = controller.joints['index-finger-tip'];
        const sphere = collideObject(indexTip);
        if (sphere) {
          const sphere2 = hand2.userData.selected;
          console.log('sphere1', sphere, 'sphere2', sphere2);
          if (sphere === sphere2) {
            scaling.active = true;
            scaling.object = sphere;
            scaling.initialScale = sphere.scale.x;
            scaling.initialDistance = indexTip.position.distanceTo(hand2.joints['index-finger-tip'].position);
            return;
          }
        }
      }
      const geometry = new THREE.BoxGeometry(SphereRadius, SphereRadius, SphereRadius);
      const material = new THREE.MeshStandardMaterial({
        color: Math.random() * 0xffffff,
        roughness: 1.0,
        metalness: 0.0
      });

      const spawn = new THREE.Mesh(geometry, material);
      spawn.geometry.computeBoundingSphere();
      const indexTip = controller.joints['index-finger-tip'];
      spawn.position.copy(indexTip.position);
      spawn.quaternion.copy(indexTip.quaternion);
      spheres.push(spawn);
      scene.add(spawn);
    }

    function onPinchStartRight(event) {
      const controller = event.target;
      const indexTip = controller.joints['index-finger-tip'];
      const object = collideObject(indexTip);
      if (object) {
        grabbing = true;
        indexTip.attach(object);
        controller.userData.selected = object;
        console.log('Selected', object);
      }
    }

    function onPinchEndRight(event) {
      const controller = event.target;
      if (controller.userData.selected !== undefined) {
        const object = controller.userData.selected;
        object.material.emissive.b = 0;
        scene.attach(object);

        controller.userData.selected = undefined;
        grabbing = false;

      }
      scaling.active = false;
    }

    function collideObject(indexTip) {
      for (let i = 0; i < spheres.length; i++) {
        const sphere = spheres[i];
        const distance = indexTip.getWorldPosition(tmpVector1).distanceTo(sphere.getWorldPosition(tmpVector2));
        if (distance < sphere.geometry.boundingSphere.radius * sphere.scale.x) {
          return sphere;
        }
      }
      return null;
    }

    init();
    animate();

    function init() {
      if (WEBGL.isWebGL2Available() === false) {
        document.body.appendChild(WEBGL.getWebGL2ErrorMessage());
      }
      container = document.getElementById('container');
      canvas = document.createElement("canvas");
      context = canvas.getContext("webgl2");
      document.body.appendChild(canvas);

      scene = new THREE.Scene();

      renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        context: context,
      }); //, antialias: true, alpha: true } );
      renderer.autoClear = false;
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.xr.enabled = true;

      document.body.appendChild(VRButton.createButton(renderer));
      container.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        10
      );
      camera.position.set(0, 1.6, 3);

      // Controller
      controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1.6, 0);
      controls.update();
      // controls.addEventListener("change", render);
      controls.update();

      controller1 = renderer.xr.getController(0);
      scene.add(controller1);

      controller2 = renderer.xr.getController(1);
      scene.add(controller2);

      const controllerModelFactory = new XRControllerModelFactory();
      const handModelFactory = new XRHandModelFactory();

      // Hand 1
      controllerGrip1 = renderer.xr.getControllerGrip(0);
      controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
      scene.add(controllerGrip1);

      hand1 = renderer.xr.getHand(0);
      hand1.addEventListener('pinchstart', onPinchStartLeft);
      hand1.addEventListener('pinchend', () => {

        scaling.active = false;

      });
      hand1.add(handModelFactory.createHandModel(hand1));

      scene.add(hand1);

      // Hand 2
      controllerGrip2 = renderer.xr.getControllerGrip(1);
      controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
      scene.add(controllerGrip2);

      hand2 = renderer.xr.getHand(1);
      hand2.addEventListener('pinchstart', onPinchStartRight);
      hand2.addEventListener('pinchend', onPinchEndRight);
      hand2.add(handModelFactory.createHandModel(hand2));
      scene.add(hand2);

      const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, - 1)]);

      const line = new THREE.Line(geometry);
      line.name = 'line';
      line.scale.z = 5;

      controller1.add(line.clone());
      controller2.add(line.clone());

      // AXES HELPER
      var axesHelper = new THREE.AxesHelper();
      axesHelper.isLineSegments = true;
      scene.add(axesHelper);

      video = document.createElement("video");
      video.src = "visualizeColorFromVideoInVR/video_html_data/razi.mp4";
      video.load();
      video.muted = true;
      video.loop = true;

      video.onloadeddata = function () {
        videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.NearestFilter;
        videoTexture.magFilter = THREE.NearestFilter;
        videoTexture.generateMipmaps = false;
        videoTexture.format = THREE.RGBAFormat;

        let discret = 10;
        const positions = [];
        for (let i = 0; i < video.videoHeight; i += discret)
          for (let j = 0; j < video.videoWidth; j += discret) {
            // positions
            const x = (i + 0.5) / video.videoHeight;
            const y = (j + 0.5) / video.videoWidth;
            const z = 0;
            positions.push(x, y, z);
          }

        // Color Space Material
        const colorSpaceMaterial = new SpaceMaterial('RGBVertexShader', 'RGBFragmentShader').material;
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        colorSpacePoints = new THREE.Points(geometry, colorSpaceMaterial);

        // Shadow Space Material
        const shadowSpaceMaterial = new SpaceMaterial('ShadowVertexShader', 'ShadowFragmentShader').material;
        shadowSpacePoints = new THREE.Points(geometry, shadowSpaceMaterial);
        // setPointsPosition(colorSpacePoints, shadowSpacePoints, 1, 1, 0);
        setPointsPosition(colorSpacePoints, shadowSpacePoints, 0, 0, 0);

        // Density Color Space Material
        const densityColorSpaceMaterial = colorSpaceMaterial.clone();
        densityColorSpaceMaterial.blending = THREE.AdditiveBlending;
        densityColorSpaceMaterial.transparent = true;
        densityColorPoints = new THREE.Points(geometry, densityColorSpaceMaterial);
        // setPointsPosition(densityColorPoints, shadowSpacePoints.clone(), -1, 1, 0);

        // Create GUI
        const meshList = [colorSpacePoints, shadowSpacePoints, densityColorPoints];
        createGUI(meshList);

        // Original Video
        var geometry2 = new THREE.PlaneGeometry(
          1,
          video.videoHeight / video.videoWidth
        );
        var material2 = new THREE.MeshBasicMaterial({
          map: videoTexture,
          side: THREE.DoubleSide,
        });
        plan = new THREE.Mesh(geometry2, material2);
        plan.position.z = -0.5;
        plan.receiveShadow = false;
        plan.castShadow = false;
        scene.add(plan);
        video.play();
      };

      window.addEventListener("resize", onWindowResize, false);
    }

    // function render() {
    //   renderer.clear();
    //   renderer.render(scene, camera);
    // }

    // function animate() {
    //   requestAnimationFrame(animate);
    //   controls.update();
    //   render();
    // }

    // VR
    function animate() {
      renderer.setAnimationLoop(render);
    }

    function render() {
      if (scaling.active) {
        const indexTip1Pos = hand1.joints['index-finger-tip'].position;
        const indexTip2Pos = hand2.joints['index-finger-tip'].position;
        const distance = indexTip1Pos.distanceTo(indexTip2Pos);
        const newScale = scaling.initialScale + distance / scaling.initialDistance - 1;
        scaling.object.scale.setScalar(newScale);
      }
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      render();
    }
  </script>
</body>

</html>